name: Docker Image CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:

  build:

    runs-on: ubuntu-latest

    steps:
    # CONSTRUYO
    # 1. Clono el repositorio
    - name: Checkout repository
      uses: actions/checkout@v4

     # 2. Configuro Docker
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      # Uso v3 porque es la misma del checkout
      # BuildX sirve para construir imágenes de Docker

      # 3. Levantar docker con docker-compose
    - name: Start Docker services
      run: docker compose up -d --build
      # Construye las imágenes de Docker basándose en el docker-compose
      # -d para hacerlo en segundo plano
      # Resultado del paso: Los contenedores quedan listos para correr las acciones

    # EMPIEZA EL PROCESO
    # Trato backend y frontend por separado

    # 4. Backend - Ejecutar tests
    - name: Run backend tests
      run: docker compose exec backend npm test
      # Ejecuta los tests que tengo en backend/test
      # docker exec es para correr un comando dentro del contenedor ya levantado -> deli-lunch-backend
    
    
       # 5 Frontend - Build y test
    # Verifico que el build del frontend generó archivos estáticos
    # En nginx, /usr/share/nginx/html es la carpeta pública desde donde se sirven esos archivos
    # Con este comando listamos el contenido para comprobar que estén (ej: index.html, css, js)
    - name: Verify frontend build
      run: docker compose exec frontend ls -la /usr/share/nginx/html
      # El build ya se hizo durante docker compose up --build
      # Solo verificamos que los archivos estén en la carpeta correcta de nginx


    # 6. Verificar que los servicios estén corriendo correctamente
    # Primero listamos los contenedores activos para confirmar que backend y frontend están levantados
    - name: Check running services
      run: docker compose ps
      # Verifico que ambos contenedores estén corriendo

    # Probamos la conectividad del backend consultando su endpoint en http://localhost:4000
    # curl -f devuelve error si la respuesta no es 2xx/3xx → así validamos que realmente responde
    - run: docker compose exec backend curl -f http://localhost:4000

    # Probamos que nginx esté sirviendo el frontend en http://localhost:80
    # Si devuelve contenido (ej: index.html), significa que el frontend está accesible
    - run: docker compose exec frontend curl -f http://localhost:80
      # Verifico que nginx sirva los archivos del frontend correctamente

      # 7. Apagar los servicios del docker
    - name: Stop Docker services
      run: docker compose down
      # Apago y limpio los contenedores levantados
